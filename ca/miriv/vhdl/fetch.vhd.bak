library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.core_pkg.all;
use work.op_pkg.all;
use work.mem_pkg.all;

entity fetch is
	port (
		clk        : in  std_logic;
		res_n      : in  std_logic;
		stall      : in  std_logic;
		flush      : in  std_logic;

		-- to control
		mem_busy   : out std_logic;

		pcsrc      : in  std_logic;
		pc_in      : in  pc_type;
		pc_out     : out pc_type := (others => '0');
		instr      : out instr_type;

		-- memory controller interface
		mem_out   : out mem_out_type;
		mem_in    : in  mem_in_type
	);
end entity;

architecture rtl of fetch is
	--Internal Program Counter:
	constant PC_RESET : unsigned(pc_type'length-1 downto 0) := (others => '0');
	signal pc : unsigned(pc_type'length-1 downto 0) := PC_RESET;
	
begin
	--Permanent Hardwires:
	mem_busy <= mem_in.busy; -- memory signals through-put
	pc_out <= std_logic_vector(pc);
	
	--Synchronous Fetch Logic:
	logic_sync: process(clk)
	begin
		if rising_edge(clk) then
			if (res_n = '0') then -- reset PC to zero
				pc <= PC_RESET;
			elsif (stall = '0') then -- only update when not stalled
				if (flush = '1') then
					instr <= NOP_INST;
				else
					instr <= (others => '0'); -- TODO
				end if;
				
				if (pcsrc = '1') then
					pc <= unsigned(pc_in);
				else -- increment 
					pc <= pc + 4;
				end if;
				
				
			end if;
		end if;
	end process;

	
end architecture;
